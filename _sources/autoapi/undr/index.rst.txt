



:py:mod:`undr`
==============

.. py:module:: undr



Submodules
----------
.. toctree::
    :titlesonly:
    :maxdepth: 1

    bibtex/index.rst
    check/index.rst
    configuration/index.rst
    constants/index.rst
    decode/index.rst
    display/index.rst
    exception/index.rst
    formats/index.rst
    install_mode/index.rst
    json_index/index.rst
    json_index_tasks/index.rst
    path/index.rst
    path_directory/index.rst
    persist/index.rst
    raw/index.rst
    remote/index.rst
    simple/index.rst
    task/index.rst
    utilities/index.rst
    version/index.rst

Overview
--------
Classes
~~~~~~~
.. list-table::
    :header-rows: 0
    :widths: auto
    :class: autoapi-summary

    * - :py:obj:`ApsFile <undr.ApsFile>`
      - A file that contains luminance (grey levels) frames.
    * - :py:obj:`Configuration <undr.Configuration>`
      - Represents a dataset configuration (TOML).
    * - :py:obj:`Directory <undr.Directory>`
      - A file or directory in a dataset.
    * - :py:obj:`DirectoryScanned <undr.DirectoryScanned>`
      - Reports information on a local directory.
    * - :py:obj:`DvsFile <undr.DvsFile>`
      - A file that contains DVS (polarity) events.
    * - :py:obj:`File <undr.File>`
      - Represents a local or remote file.
    * - :py:obj:`ImuFile <undr.ImuFile>`
      - A file that contains IMU events.
    * - :py:obj:`Index <undr.Index>`
      - Downloads an index file (-index.json).
    * - :py:obj:`IndexStatus <undr.IndexStatus>`
      - Keeps track of the indexing progress for a dataset.
    * - :py:obj:`IndexesStatuses <undr.IndexesStatuses>`
      - Maps dataset names to index statuses.
    * - :py:obj:`Manager <undr.Manager>`
      - Schedules and keeps track of tasks.
    * - :py:obj:`Mode <undr.Mode>`
      - Download strategy for a dataset.
    * - :py:obj:`ProcessFile <undr.ProcessFile>`
      - Generic task for file processing.
    * - :py:obj:`ProcessFilesRecursive <undr.ProcessFilesRecursive>`
      - Spawns a processing task for each file in the given directory.
    * - :py:obj:`ProcessManager <undr.ProcessManager>`
      - Implements a manager that controls a pool of worker processes.
    * - :py:obj:`ReadOnlyStore <undr.ReadOnlyStore>`
      - Stores the IDs of processed tasks.
    * - :py:obj:`Selector <undr.Selector>`
      - Delegate called to pick an action for each file.
    * - :py:obj:`Store <undr.Store>`
      - Stores the IDs of processed tasks.
    * - :py:obj:`Switch <undr.Switch>`
      - Calls specialized file handlers while iterating a dataset.
    * - :py:obj:`Task <undr.Task>`
      - A processing task to be performed by a worker.


Functions
~~~~~~~~~
.. list-table::
    :header-rows: 0
    :widths: auto
    :class: autoapi-summary

    * - :py:obj:`configuration_from_path <undr.configuration_from_path>`
      - Reads the configuration (TOML) with the given path.
    * - :py:obj:`default_datasets <undr.default_datasets>`
      - Generates a list of the default datasets' names.
    * - :py:obj:`install <undr.install>`
      - Downloads (and optionally decompresses) a dataset.


Attributes
~~~~~~~~~~
.. list-table::
    :header-rows: 0
    :widths: auto
    :class: autoapi-summary

    * - :py:obj:`SendMessage <undr.SendMessage>`
      - Callback channel for messages generated by a file handler during data iteration.
    * - :py:obj:`__version__ <undr.__version__>`
      - UNDR's version, conforms to Semantic Versioning 2.0.0.


Package Contents
----------------

.. py:class:: ApsFile


   Bases: :py:obj:`undr.path.File`

   A file that contains luminance (grey levels) frames.

   Active-pixel sensors (APS) describe, strictly speaking, any sensor with pixels that use MOSFET amplifiers.
   However, the term is commonly used to refer to the integrating pixels found in non-CCD conventional cameras.
   In the context of Neuromorphic Engineering, APS is used to describe DAVIS frames.

   .. py:attribute:: height
      :type: int

      Frame height (y direction) in pixels.

   .. py:attribute:: width
      :type: int

      Frame width (x direction) in pixels.

   .. py:method:: packets() -> Iterable[numpy.ndarray]

      Iterates over the file data.

      This function streams the file from the remote server if it is not available locally, and decompresses the file in memory if it is locally available but compressed.

      :returns: Iterator over the file's data converted into numpy arrays with dtype :py:func:`undr.raw.aps_dtype`.
      :rtype: typing.Iterable[numpy.ndarray]


   .. py:method:: word_size() -> int

      The size of an entry in this file, in bytes.

      This can be used to ensure that entries (events, frames...) are not split while reading.
      A decoded file's size in bytes must be a multiple of the value returned by this function.

      :returns: Number of bytes used by each entry.
      :rtype: int



.. py:class:: Configuration


   Represents a dataset configuration (TOML).

   .. py:attribute:: directory
      :type: pathlib.Path

      Local path of the root datasets directory (usually called *datasets*).

   .. py:attribute:: name_to_dataset_settings
      :type: dict[str, DatasetSettings]

      Maps dataset names to their parameters.

   .. py:method:: bibtex(show_display: bool, workers: int, force: bool, bibtex_timeout: float, log_directory: Optional[pathlib.Path]) -> str

      Downloads index files and BibTeX references for enabled datasets.

      :param show_display: Whether to show progress in the terminal.
      :type show_display: bool
      :param workers: Number of parallel workers (threads).
      :type workers: int
      :param force: Whether to re-download resources even if they are already present locally.
      :type force: bool
      :param bibtex_timeout: Timeout for requests to https://dx.doi.org/.
      :type bibtex_timeout: float
      :param log_directory: Directory to store log files. Logs are not generated if this is None.
      :type log_directory: typing.Optional[pathlib.Path]

      :raises task.WorkerException: if a worker raises an error.

      :returns: BibTeX references as a string.
      :rtype: str


   .. py:method:: dataset(name: str) -> undr.path_directory.Directory

      Returns the dataset with the given name.

      :param name: The dataset name.
      :type name: str

      :raises ValueError: if the dataset exists but is disabled.

      :returns: The dataset's root directory.
      :rtype: path_directory.Directory


   .. py:method:: display(download_tag: undr.display.Tag = display.Tag(label='download', icon='↓'), process_tag: undr.display.Tag = display.Tag(label='process', icon='⚛')) -> undr.display.Display

      Returns a display that shows download and process progress for enabled datasets.

      :param download_tag: Label and icon for download. Defaults to display.Tag(label="download", icon="↓").
      :type download_tag: display.Tag, optional
      :param process_tag: Label and icon for process. Defaults to display.Tag(label="process", icon="⚛").
      :type process_tag: display.Tag, optional

      :returns: Controller for the display thread.
      :rtype: display.Display


   .. py:method:: enabled_datasets_settings() -> list[DatasetSettings]

      The settings of enabled datasets.

      The list always contains at least one item (the function otherwise raises an error).

      :raises RuntimeError: if all the datasets are disabled or there are no datasets.

      :returns: The settings of the datasets that are enabled, in the same order as the configuration file.
      :rtype: list[DatasetSettings]


   .. py:method:: indexes_statuses(selector: undr.json_index_tasks.Selector) -> IndexesStatuses

      Builds an indexing report for enabled datasets.

      :param selector: The selector used to index the dataset.
      :type selector: json_index_tasks.Selector

      :returns: Index status for enabled datasets, in the same order as the configuration file.
      :rtype: IndexesStatuses


   .. py:method:: install(show_display: bool, workers: int, force: bool, log_directory: Optional[pathlib.Path])

      Downloads index files and data files and decompresses data files.

      The action (index only, download, download and decompress) may be different for each dataset and is controlled by :py:class:`undr.install_mode.Mode`.

      :param show_display: Whether to show progress in the terminal.
      :type show_display: bool
      :param workers: Number of parallel workers (threads).
      :type workers: int
      :param force: Whether to re-download resources even if they are already present locally.
      :type force: bool
      :param log_directory: Directory to store log files. Logs are not generated if this is None.
      :type log_directory: typing.Optional[pathlib.Path]

      :raises task.WorkerException: if a worker raises an error.


   .. py:method:: iter(recursive: bool = False) -> Iterable[undr.path.Path]

      Iterates the files in the dataset.

      :param recursive: Whether to recursively search child directories. Defaults to False.
      :type recursive: bool, optional

      :returns: Iterator over the child paths. If `recursive` is false, the iterator yields the direct children (files and directories) of the root dataset directory. If `recursive` is true, the iterator yields all the children (files and directories) of the dataset.
      :rtype: typing.Iterable[path.Path]


   .. py:method:: map(switch: undr.formats.Switch, store: Optional[undr.persist.Store] = None, show_display: bool = True, workers: int = multiprocessing.cpu_count() * 2, log_directory: Optional[pathlib.Path] = None) -> Iterable[Any]

      Applies a function to eacch file in a dataset.

      :param switch: Specifies the action to perform on each file type.
      :type switch: formats.Switch
      :param store: Saves progress, makes it possible to resume interrupted processing. Defaults to None.
      :type store: typing.Optional[persist.Store], optional
      :param show_display: Whether to show progress in the terminal. Defaults to True.
      :type show_display: bool, optional
      :param workers: Number of parallel workers (threads). Defaults to twice :py:func:`multiprocessing.cpu_count`.
      :type workers: int, optional
      :param log_directory: Directory to store log files. Logs are not generated if this is None. Defaults to None.
      :type log_directory: typing.Optional[pathlib.Path], optional

      :raises task.WorkerException: if a worker raises an error.

      :returns: Iterator over the non-error messages generated by the workers.
      :rtype: typing.Iterable[typing.Any]


   .. py:method:: mktree(root: Union[str, os.PathLike], parents: bool = False, exist_ok: bool = False)

      Creates a copy of the datasets' file hierarchy without the index or data files.

      This function can be combined with :py:func:`map` to implement a map-reduce algorithm over entire datasets.
          a. Use ``mktree`` to create a empty copy of the file hierarchy.
          b. Use :py:meth:`Configuration.map` to create a result file in the new hierarchy for each data file in the originall hierarchy (for instance, a file that contains a measure algorithm's performance as a single number).
          c. Collect the results ("reduce") by reading the result files in the new hierarchy.

      This approach has several benefits. The most expensive step b. runs in parallell and can be interrupted and resumed. Result files are stored in a different directory and can easily be deleted without altering the original data. The new file hierarchy prevents name clashes as long as result files are named after data files, and workers do not need to worry about directory existence since ``mktree`` runs first.

      :param root: Directory where the new file hierarchy is created.
      :type root: typing.Union[str, os.PathLike]
      :param parents: Whether to create the parents of the new directory, if they do not exist. Defaults to False.
      :type parents: bool, optional
      :param exist_ok: Whether to silence exeptions if the root directory already exists. Defaults to False.
      :type exist_ok: bool, optional



.. py:class:: Directory


   Bases: :py:obj:`undr.path.Path`

   A file or directory in a dataset.

   A path can point to a local resource or represent a remote resource.

   .. py:attribute:: doi_and_metadata_loaded
      :type: bool

      

   .. py:method:: __getattribute__(__name: str)

      Return getattr(self, name).


   .. py:method:: __truediv__(other: str) -> undr.path.Path

      Concatenates this path with a string to create a new path.

      :param other: Suffix to append to this path.
      :type other: str

      :returns: The concatenated result.
      :rtype: Path


   .. py:method:: iter(recursive: bool = False) -> Iterable[undr.path.Path]



.. py:class:: DirectoryScanned


   Reports information on a local directory.

   .. py:attribute:: download_bytes
      :type: IndexProgress

      Total size of the compressed files in this directory, in bytes.

      This size does not include -index.json.

   .. py:attribute:: final_count
      :type: int

      Total number of files in this directory ("files" and "other_files").

      This count does not include -index.json.

   .. py:attribute:: index_bytes
      :type: IndexProgress

      Size of the index file (-index.json) in bytes.

   .. py:attribute:: initial_download_count
      :type: int

      Number of files already downloaded when the action started ("files" and "other_files").

      This count does not include -index.json.

   .. py:attribute:: initial_process_count
      :type: int

      Number of files already processed when the action started ("files" and "other_files").

      This count does not include -index.json.

   .. py:attribute:: path_id
      :type: pathlib.PurePosixPath

      Path ID of the directory.

   .. py:attribute:: process_bytes
      :type: IndexProgress

      Total size of the files in this directory, in bytes.

      This size does not include -index.json.


.. py:class:: DvsFile


   Bases: :py:obj:`undr.path.File`

   A file that contains DVS (polarity) events.

   Dynamic Vision Sensor events, often called polarity events,
   contain a timestamp, pixel coordinates, and a polarity (ON or OFF)
   that indicates whether luminance increased or decreased.

   .. py:attribute:: height
      :type: int

      Frame height (y direction) in pixels.

   .. py:attribute:: width
      :type: int

      Frame width (x direction) in pixels.

   .. py:method:: packets() -> Iterable[numpy.ndarray]

      Iterates over the file data.

      This function streams the file from the remote server if it is not available locally, and decompresses the file in memory if it is locally available but compressed.

      :returns: Iterator over the file's data converted into numpy arrays with dtype :py:attr:`undr.raw.DVS_DTYPE`.
      :rtype: typing.Iterable[numpy.ndarray]


   .. py:method:: word_size()

      The size of an entry in this file, in bytes.

      This can be used to ensure that entries (events, frames...) are not split while reading.
      A decoded file's size in bytes must be a multiple of the value returned by this function.

      :returns: Number of bytes used by each entry.
      :rtype: int



.. py:class:: File


   Bases: :py:obj:`Path`

   Represents a local or remote file.

   .. py:attribute:: compressions
      :type: tuple[undr.decode.Compression, Ellipsis]

      List of compressions available on the server.

   .. py:attribute:: hash
      :type: str

      The decompressed file hash (SHA3-224).

   .. py:attribute:: manager
      :type: undr.task.Manager

      Can be called to schedule new tasks and report updates.

   .. py:attribute:: session
      :type: Optional[requests.Session]

      An open session that can be used to download resources.

   .. py:attribute:: size
      :type: int

      The decompressed file size in bytes.

   .. py:method:: __truediv__(other: str) -> Path

      Concatenates this path with a string to create a new path.

      :param other: Suffix to append to this path.
      :type other: str

      :returns: The concatenated result.
      :rtype: Path


   .. py:method:: _chunks(word_size: int) -> Iterable[bytes]

      Returns an iterator over the file's decompressed bytes.

      Users should prefer :py:func:`chunks` since files know their word size.

      :param word_size: size of an entry (events, frames...) in the file.
      :type word_size: int

      :raises decode.RemainingBytesError: if the total file size is not a multiple of `word_size`.
      :raises Exception: if the hash is incorrect.

      :returns: Iterator over the file's decompressed bytes.
      :rtype: typing.Iterable[bytes]


   .. py:method:: attach_manager(manager: Optional[undr.task.Manager])

      Binds a manager to this file.

      The file sends all subsequent updates (download and processing) to the manager.

      :param manager: The manager to use to keep track of progress.
      :type manager: typing.Optional[task.Manager]


   .. py:method:: attach_session(session: Optional[requests.Session])

      Binds a session to this file.

      The session is used for all subsequent downloads.

      :param session: An open session to use for downloads.
      :type session: typing.Optional[requests.Session]


   .. py:method:: attributes_from_dict(data: dict[str, Any], parent: undr.path_directory.Directory) -> dict[str, Any]
      :staticmethod:

      Converts -index.json data to a dict of this class's arguments.

      The returned dict can be used to initialise an instance of this class.

      :param data: Parsed JSON data.
      :type data: dict[str, typing.Any]
      :param parent: The file's parent directory.
      :type parent: path_directory.Directory

      :returns: Data that can be used to initialize this class.
      :rtype: dict[str, typing.Any]


   .. py:method:: best_compression() -> undr.decode.Compression

      Returns the best compression supported by the remote server for this file.

      Best is defined here as "smallest encoded size".

      :returns: Compression format that yields the smallest version of this file.
      :rtype: decode.Compression


   .. py:method:: chunks() -> Iterable[bytes]

      Returns an iterator over the file's decompressed bytes.

      :returns: Iterator over the decompressed file's bytes. The size of the chunks may vary.
      :rtype: typing.Iterable[bytes]


   .. py:method:: from_dict(data: dict[str, Any], parent: undr.path_directory.Directory)
      :classmethod:

      Conerts -index.json data to an instance of this class.

      :param data: Parsed JSON data.
      :type data: dict[str, typing.Any]
      :param parent: The file's parent directory.
      :type parent: path_directory.Directory

      :returns: The file represented by the given data.
      :rtype: File


   .. py:method:: word_size() -> int

      The size of an entry in this file, in bytes.

      This can be used to ensure that entries (events, frames...) are not split while reading.
      A decoded file's size in bytes must be a multiple of the value returned by this function.

      :returns: Number of bytes used by each entry.
      :rtype: int



.. py:class:: ImuFile


   Bases: :py:obj:`undr.path.File`

   A file that contains IMU events.

   Inertial Measurement Unit (IMU) events are produced by an accelerometer / gyroscope / magnetometer.

   .. py:method:: packets() -> Iterable[numpy.ndarray]

      Iterates over the file data.

      This function streams the file from the remote server if it is not available locally, and decompresses the file in memory if it is locally available but compressed.

      :returns: Iterator over the file's data converted into numpy arrays with dtype :py:attr:`undr.raw.IMU_DTYPE`.
      :rtype: typing.Iterable[numpy.ndarray]


   .. py:method:: word_size()

      The size of an entry in this file, in bytes.

      This can be used to ensure that entries (events, frames...) are not split while reading.
      A decoded file's size in bytes must be a multiple of the value returned by this function.

      :returns: Number of bytes used by each entry.
      :rtype: int



.. py:class:: Index(path_root: pathlib.Path, path_id: pathlib.PurePosixPath, server: undr.remote.Server, selector: Selector, priority: int, force: bool, directory_doi: bool)


   Bases: :py:obj:`undr.remote.DownloadFile`

   Downloads an index file (-index.json).

   :param path_root: The root path used to generate local file paths.
   :type path_root: pathlib.Path
   :param path_id: The path ID of the directory that will be seached recursively.
   :type path_id: pathlib.PurePosixPath
   :param server: The remote server to download resources.
   :type server: remote.Server
   :param selector: A selector that defines the files to process.
   :type selector: Selector
   :param priority: Priority of this task (tasks with lower priorities are scheduled first).
   :type priority: int
   :param force: Download the index file even if it is already present locally.
   :type force: bool
   :param directory_doi: Whether to dispatch :py:class:`Doi` messages while reading the index.
   :type directory_doi: bool

   .. py:method:: run(session: requests.Session, manager: undr.task.Manager)



.. py:class:: IndexStatus


   Keeps track of the indexing progress for a dataset.

   .. py:attribute:: current_index_files
      :type: int

      Number of index files parsed.

      The dataset has been indexed if :py:attr:`current_index_files` and :py:attr:`final_index_files` are equal.

   .. py:attribute:: dataset_settings
      :type: DatasetSettings

      User-specified dataset settings.

   .. py:attribute:: downloaded_and_processed
      :type: bool

      Whether the dataset has been fully downloaded and processed.

   .. py:attribute:: final_index_files
      :type: int

      Total number of index files.

   .. py:attribute:: selector
      :type: undr.json_index_tasks.Selector

      Selector to choose actions while indexing.

   .. py:attribute:: server
      :type: undr.remote.Server

      The remote server for this dataset.

   .. py:method:: push(message: Any) -> tuple[bool, Optional[IndexStatus]]

      Updates the status based on the message.

      Ignores messages that are not :py:class:`undr.json_index_tasks.IndexLoaded` or :py:class:`undr.json_index_tasks.DirectoryScanned`.

      :returns: Whether the dataset has been fully indexed and self, if self was updated.
      :rtype: tuple[bool, typing.Optional["IndexStatus"]]



.. py:class:: IndexesStatuses


   Maps dataset names to index statuses.

   .. py:attribute:: name_to_status
      :type: dict[str, IndexStatus]

      Inner dict.

   .. py:method:: push(message: Any) -> tuple[bool, Optional[IndexStatus]]

      Processes relevant messages.

      This function updates the indexing status and returns it
      if message is a :py:class:`undr.json_index_tasks.IndexLoaded` or :py:class:`undr.json_index_tasks.DirectoryScanned` object.
      If the message was the last indexing message for this dataset, the first argument is True.



.. py:class:: Manager


   Schedules and keeps track of tasks.

   This is an abtract class, use of one of its implementations such as :py:class:`ProcessManager` to create objects.

   .. py:method:: schedule(task: Task, priority: int = 1) -> None
      :abstractmethod:

      Runs a task with the given priority.

      Tasks with lower priorities are scheduled first. The maximum priority level depends on the implementation. At least two levels, 0 (highest priority) and 1, must be supported by all implementations.

      :param task: The task that this manager must run (possibly on a different thread).
      :type task: Task
      :param priority: Priority level. Defaults to 1.
      :type priority: int, optional


   .. py:method:: send_message(message: Any) -> None
      :abstractmethod:

      Queues a message in the manager's "inbox".

      A manager is responsible for collecting messages from all tasks, which are potentially running on different threads or processes, and serving thse messages in a single-threaded fashion to a reader.

      This function is meant to be called by tasks, which have access to the manager in their :py:meth:`Task.run` function.

      :param message: Any object. Currently implemeted managers require the message to be compatible with the :py:mod:`pickle` module.
      :type message: typing.Any



.. py:class:: Mode(*args, **kwds)


   Bases: :py:obj:`enum.Enum`

   Download strategy for a dataset.

   .. py:attribute:: DISABLED
      :value: 'disabled'

      The dataset is ignored by all actions.

   .. py:attribute:: LOCAL
      :value: 'local'

      Download all the dataset files locally but do not decompress them.

      Most datasets are stored as Brotli archives (https://github.com/google/brotli/). UNDR stream-decompresses files before processing, making this option a good trade-off between disk usage and processing speed.

   .. py:attribute:: RAW
      :value: 'raw'

      Downloads all the dataset files locally and decompresses them.

      Decompressed files use a relatively inefficient plain binary file format. This option requires vast amounts of disk space (3 to 5 times as much as the Brotli archives). However, the plain binary format facilitates processing from languages such as Matlab or C++.

   .. py:attribute:: REMOTE
      :value: 'remote'

      Only download the dataset's index files.

      UNDR can process the dataset files as if they were locally available, by streaming them from the server. This option is particularly useful for large datasets that do not fit on the hard drive but it requires a fast internet connection since files are re-downloaded every time.


.. py:class:: ProcessFile(file: undr.path.File)


   Bases: :py:obj:`undr.task.Task`

   Generic task for file processing.

   :param file: The file (remote or local) to process.
   :type file: path.File


.. py:class:: ProcessFilesRecursive(path_root: pathlib.Path, path_id: pathlib.PurePosixPath, server: undr.remote.Server, selector: Selector, process_file_class: Type[ProcessFileType], process_file_args: Iterable[Any], process_file_kwargs: Mapping[str, Any], priority: int)


   Bases: :py:obj:`undr.task.Task`

   Spawns a processing task for each file in the given directory.

   Subdirectories are recursively searched as well.

   :param path_root: The root path used to generate local file paths.
   :type path_root: pathlib.Path
   :param path_id: The path ID of the directory that will be scanned recursively.
   :type path_id: pathlib.PurePosixPath
   :param server: The remote server used to download resources.
   :type server: remote.Server
   :param selector: A selector that defines the files to process.
   :type selector: Selector
   :param process_file_class: The class of the task to run on each selected file. Must be a subclass of :py:class:`ProcessFile`.
   :type process_file_class: typing.Type[ProcessFileType]
   :param process_file_args: Positional arguments passed to the constructor of `process_file_class`.
   :type process_file_args: typing.Iterable[typing.Any]
   :param process_file_kwargs: Keyword arguments passed to the constructor of `process_file_class`. The keyword argument `file` is automatically added by `ProcessFilesRecursive` after the positional arguments and before other keyword arguments.
   :type process_file_kwargs: typing.Mapping[str, typing.Any]
   :param priority: Priority of this task and all recursively created tasks (tasks with lower priorities are scheduled first).
   :type priority: int

   .. py:method:: run(session: requests.Session, manager: undr.task.Manager) -> None



.. py:class:: ProcessManager(workers: int = multiprocessing.cpu_count() * 2, priority_levels: int = 2, log_directory: Optional[pathlib.Path] = None)


   Bases: :py:obj:`Manager`

   Implements a manager that controls a pool of worker processes.

   This class is similar to :py:class:`multiprocessing.pool.Pool` but it has better support for user-initiated shutdowns (sigint / CTRL-C) and worker-initiated shutdowns (exceptions). It also supports priorities levels.

   Whenever a worker is idle, the manager scans its (the manager's) task queues in order of priority until it finds a non-empty queue, and sends the first task from that queue to the worker. Hence, tasks with lower priorities are scheduled first. However, since a task may asynchronously spawn more tasks with arbitrary priority levels, there is no guarantee that all tasks with priority 0 spawned by a program overall are executed before all tasks with priority 1. In particular, tasks are never cancelled, even if a task with a lower priority level (i.e. more urgent) becomes available while a worker is already running a task with a higher priority level (i.e. less urgent).

   :param workers: Number of parallel workers (threads). Defaults to twice :py:func:`multiprocessing.cpu_count`.
   :type workers: int, optional
   :param priority_levels: Number of priority queues. Defaults to 2.
   :type priority_levels: int, optional
   :param log_directory: Directory to store log files. Logs are not generated if this is None. Defaults to None.
   :type log_directory: typing.Optional[pathlib.Path], optional

   .. py:class:: ClosePolicy(*args, **kwds)


      Bases: :py:obj:`enum.Enum`

      Strategy used to terminate worker threads.

      .. py:attribute:: CANCEL
         :value: 1

         Shutdown threads without consuming buffered messages.

         This should be used to stop thread workers after user-initiated cancellation (CTRL-C).

      .. py:attribute:: JOIN
         :value: 0

         Consume all messages and shutdown threads.

         This should be used to wait for the end of the program normally.

      .. py:attribute:: KILL
         :value: 2

         Kill threads without consuming buffered messages.

         This should be used after a thread raises an error, to stop the remaning worker threads.


   .. py:class:: Proxy(server_port: int)


      Bases: :py:obj:`Manager`

      Manager interface that can be sent to workers.

      Since :py:class:`ProcessManager` implements a custom message passing system and owns message queues, it cannot be shared between processes. Worker processes require a handle to the manager to send messages and schedule new tasks. However, the handle does not have to be the actual manager, it is merely a means to pass around the two fuctions of its public API. This proxy prentends to be the manager but forwards messages to the actual manager using TCP. See :py:func:`send_bytes` for a description of message encoding.

      :param server_port: Port of the manager's TCP server used to send messages between workers and the manager.
      :type server_port: int

      .. py:method:: acknowledge_and_next_task() -> Union[None, Task, CloseRequest]

         Called by a worker to indicate that they completed the current task and are asking for a new one.

         :returns: None if there are no tasks waiting (but more tasks may become available in the future), a :py:class:`Task` instance if the manager returned a task for this worker, and :py:class:`CloseRequest` must shutdown.
         :rtype: typing.Union[None, Task, CloseRequest]


      .. py:method:: next_task() -> Union[None, Task, CloseRequest]

         Called by a worker to receive the next task.

         :returns: None if there are no tasks waiting (but more tasks may become available in the future), a :py:class:`Task` instance if the manager returned a task for this worker, and :py:class:`CloseRequest` must shutdown.
         :rtype: typing.Union[None, Task, CloseRequest]


      .. py:method:: schedule(task: Task, priority: int = 1)

         Runs a task with the given priority.

         Tasks with lower priorities are scheduled first. The maximum priority level depends on the implementation. At least two levels, 0 (highest priority) and 1, must be supported by all implementations.

         :param task: The task that this manager must run (possibly on a different thread).
         :type task: Task
         :param priority: Priority level. Defaults to 1.
         :type priority: int, optional


      .. py:method:: send_message(message: Any)

         Queues a message in the manager's "inbox".

         A manager is responsible for collecting messages from all tasks, which are potentially running on different threads or processes, and serving thse messages in a single-threaded fashion to a reader.

         This function is meant to be called by tasks, which have access to the manager in their :py:meth:`Task.run` function.

         :param message: Any object. Currently implemeted managers require the message to be compatible with the :py:mod:`pickle` module.
         :type message: typing.Any


      .. py:method:: setup()

         Called by each worker to create the TCP connection with the actual manager.



   .. py:class:: RequestHandler(request, client_address, server)


      Bases: :py:obj:`socketserver.BaseRequestHandler`

      Processes TCP requests for the actual manager (TCP server).

      .. py:method:: handle()

         Processes a TCP request.

         See :py:func:`send_bytes` for a description of message encoding.



   .. py:method:: __enter__()

      Enables the use of the "with" statement.

      :returns: A process manager context that calls :py:meth:`close` on exit.
      :rtype: ProcessManager


   .. py:method:: __exit__(type: Optional[Type[BaseException]], value: Optional[BaseException], traceback: Optional[types.TracebackType])

      Enables the use of the "with" statement.

      This function calls :py:meth:`close` with the policy :py:attr:`ProcessManager.ClosePolicy.CANCEL` if there is no active exception (typically caused by a soft cancellation) and with the policy :py:attr:`ProcessManager.ClosePolicy.KILL` if there is an active exception.

      :param type: None if the context exits without an exception, and the raised exception's class otherwise.
      :type type: typing.Optional[typing.Type[BaseException]]
      :param value: None if the context exits without an exception, and the raised exception otherwise.
      :type value: typing.Optional[BaseException]
      :param traceback: None if the context exits without an exception, and the raised exception's traceback otherwise.
      :type traceback: typing.Optional[types.TracebackType]


   .. py:method:: close(policy: ProcessManager)

      Terminates the manager.

      Depending on  the value of policy, this function will return almost immediately or block until all the tasks complete. See :py:class:`ProcessManager.ClosePolicy` for details.

      :param policy: Termination policy for the manager and its workers.
      :type policy: ProcessManager.ClosePolicy


   .. py:method:: messages() -> Iterable[Any]

      Iterates over the messages sent by all workers until all the tasks are complete.

      The thread that iterates over the messages has access to the manager and may use it to schedule new tasks.

      :returns: Iterator over messages from all workers.
      :rtype: typing.Iterable[typing.Any]


   .. py:method:: schedule(task: Task, priority: int = 1)

      Runs a task with the given priority.

      Tasks with lower priorities are scheduled first. The maximum priority level depends on the implementation. At least two levels, 0 (highest priority) and 1, must be supported by all implementations.

      :param task: The task that this manager must run (possibly on a different thread).
      :type task: Task
      :param priority: Priority level. Defaults to 1.
      :type priority: int, optional


   .. py:method:: send_message(message: Any)

      Queues a message in the manager's "inbox".

      A manager is responsible for collecting messages from all tasks, which are potentially running on different threads or processes, and serving thse messages in a single-threaded fashion to a reader.

      This function is meant to be called by tasks, which have access to the manager in their :py:meth:`Task.run` function.

      :param message: Any object. Currently implemeted managers require the message to be compatible with the :py:mod:`pickle` module.
      :type message: typing.Any


   .. py:method:: serve()

      Server thread implementation.


   .. py:method:: target(proxy: ProcessManager, log_directory: Optional[pathlib.Path])
      :staticmethod:

      Worker thread implementation.

      :param proxy: The manager proxy to request tasks, spawn new tasks, and send messages.
      :type proxy: ProcessManager.Proxy
      :param log_directory: Directory to store log files. Logs are not generated if this is None.
      :type log_directory: typing.Optional[pathlib.Path]



.. py:class:: ReadOnlyStore(path: Union[str, os.PathLike])


   Stores the IDs of processed tasks.

   This store provides a method to check whether a task has been performed but it cannot be modified.
   Most users will probably prefer the writable :py:class:`Store`.

   :param path: Path of the SQLite database file with extension ".db".
   :type path: typing.Union[str, os.PathLike]

   .. py:method:: __contains__(id: str)

      Whether the given ID has been processed.

      :param id: The ID to check.
      :type id: str

      :returns: True if the file is in the store, which means that it has been processed.
      :rtype: bool


   .. py:method:: __enter__()

      Enables the use of the "with" statement.

      :returns: A store context that calls :py:meth:`close` on exit.
      :rtype: Display


   .. py:method:: __exit__(type: Optional[Type[BaseException]], value: Optional[BaseException], traceback: Optional[types.TracebackType])

      Enables the use of the "with" statement.

      :param type: None if the context exits without an exception, and the raised exception's class otherwise.
      :type type: typing.Optional[typing.Type[BaseException]]
      :param value: None if the context exits without an exception, and the raised exception otherwise.
      :type value: typing.Optional[BaseException]
      :param traceback: None if the context exits without an exception, and the raised exception's traceback otherwise.
      :type traceback: typing.Optional[types.TracebackType]


   .. py:method:: __getstate__()

      Helper for pickle.


   .. py:method:: __setstate__(state: pathlib.Path)


   .. py:method:: close()

      Closes the store's database.



.. py:exception:: RemainingBytesError(word_size: int, buffer: bytes)


   Bases: :py:obj:`Exception`

   Raised if the number of bytes in the decompressed resource is not a multiple of its word size.

   :param word_size: The resource's word size.
   :type word_size: int
   :param buffer: The remaining bytes. Their length is larger than zero and smaller than the word size.
   :type buffer: bytes


.. py:class:: Selector


   Delegate called to pick an action for each file.

   Selectors are used during the indexing phase to calculate the number of bytes to download and/or process,
   and during the processing phase to choose the action to perform.

   .. py:class:: Action(*args, **kwds)


      Bases: :py:obj:`enum.Enum`

      Specifies the operation to perform for a given file.

      The action also determines whether the file's bytes should be
      accounted for during the indexing phase.
      This is useful to report non-zero progress after resuming a job,
      but skip the actual processing.

      .. py:attribute:: DECOMPRESS
         :value: 5

         Downloads, decompresses, and reports.

      .. py:attribute:: DOI
         :value: 1

         Skips this file, does not report it, but publishes own DOIs.

      .. py:attribute:: DOWNLOAD
         :value: 4

         Downloads and reports.

      .. py:attribute:: DOWNLOAD_SKIP
         :value: 3

         Skips operations on this file but reports it as downloaded.

      .. py:attribute:: IGNORE
         :value: 0

         Skips this file and does not report it.

      .. py:attribute:: PROCESS
         :value: 6

         Downloads, decompresses, processes, and reports.

      .. py:attribute:: SKIP
         :value: 2

         Skips this file but reports it as downloaded and processed.


   .. py:attribute:: INSTALL_IGNORE_ACTIONS

      The set of actions that ignore the file for reporting purposes.

   .. py:attribute:: REPORT_DOWNLOAD_ACTIONS

      The set of actions that (at least) download the file.

   .. py:attribute:: REPORT_PROCESS_ACTIONS

      The set of actions that download and process the file.

   .. py:attribute:: SKIP_ACTIONS

      The set of actions that skip all operations on the file.

   .. py:method:: action(file: undr.path.File) -> Selector

      Returns the action to apply to the given file.

      Called by :py:class:`Index`, :py:class:`InstallFilesRecursive` and :py:class:`ProcessFilesRecursive`.
      The default implementation returns `Selector.Action.PROCESS`.


   .. py:method:: scan_filesystem(directory: undr.path_directory.Directory) -> bool

      Whether to scan the filesystem.

      Called by :py:class:`Index` to decide whether it needs to scan the file system.
      This function may return False if :py:func:`action` returns one of the following for every file in the directory:

      - :py:attr:`Selector.Action.IGNORE`
      - :py:attr:`Selector.Action.DOI`
      - :py:attr:`Selector.Action.SKIP`
      - :py:attr:`Selector.Action.DOWNLOAD_SKIP`



.. py:data:: SendMessage

   Callback channel for messages generated by a file handler during data iteration.

.. py:class:: Store(path: Union[str, os.PathLike], commit_maximum_delay: float = 0.1, commit_maximum_inserts: int = 100)


   Bases: :py:obj:`ReadOnlyStore`

   Stores the IDs of processed tasks.

   :param path: Path of the SQLite database file with extension ".db".
   :type path: typing.Union[str, os.PathLike]
   :param commit_maximum_delay: How often changes are commited to the disk, in seconds. Defaults to 0.1.
   :type commit_maximum_delay: float, optional
   :param commit_maximum_inserts: Maximum number of changes before commiting changes to the disk. Defaults to 100.
   :type commit_maximum_inserts: int, optional

   .. py:class:: Commit


      Message requesting a commit (changes are immediately persited to the disk).


   .. py:class:: Reset


      Message requesting a reset of the database (existing entries are dropped).


   .. py:method:: __getstate__()

      Helper for pickle.


   .. py:method:: __setstate__(state: Tuple[pathlib.Path, int, int])


   .. py:method:: add(id: str)

      Adds a row to the database.

      The action is ignored if the entry is already in the database.

      :param id: Entry to store in the database.
      :type id: str


   .. py:method:: close()

      Closes the store's database.


   .. py:method:: commit()

      Immediately persists changes to the disk.


   .. py:method:: reset()

      Drops all entries from the database.


   .. py:method:: target()

      Worker thread implementation.



.. py:class:: Switch


   Calls specialized file handlers while iterating a dataset.

   If a handler is None, the corresponding files are ignored by the iterator.

   :param handle_aps: Handler for APS files.
   :type handle_aps: typing.Optional[typing.Callable[[ApsFile, SendMessage], None]]
   :param handle_dvs: Handler for DVS files.
   :type handle_dvs: typing.Optional[typing.Callable[[DvsFile, SendMessage], None]]
   :param handle_imu: Handler for IMU files.
   :type handle_imu: typing.Optional[typing.Callable[[ImuFile, SendMessage], None]]
   :param handle_other: Handler for other files.
   :type handle_other: typing.Optional[typing.Callable[[path.File, SendMessage], None]]

   .. py:attribute:: handle_aps
      :type: Optional[Callable[[ApsFile, SendMessage], None]]

      

   .. py:attribute:: handle_dvs
      :type: Optional[Callable[[DvsFile, SendMessage], None]]

      

   .. py:attribute:: handle_imu
      :type: Optional[Callable[[ImuFile, SendMessage], None]]

      

   .. py:attribute:: handle_other
      :type: Optional[Callable[[undr.path.File, SendMessage], None]]

      

   .. py:method:: enabled_types() -> set[Any]

      Lists the file types that have a non-None handler.

      :returns: The set of file classes that will be handled.
      :rtype: set[typing.Any]


   .. py:method:: handle_file(file: undr.path.File, send_message: SendMessage)

      Calls the specialized file handler for the file, if the handler is non-None.

      :param file: The file to process.
      :type file: path.File
      :param send_message: Callback channel for messages.
      :type send_message: SendMessage

      :raises RuntimeError: if the file type is not supported by this function.



.. py:class:: Task


   A processing task to be performed by a worker.

   .. py:method:: __repr__() -> str

      Return repr(self).


   .. py:method:: run(session: requests.Session, manager: Manager)
      :abstractmethod:



.. py:exception:: WorkerException(traceback_exception: traceback.TracebackException)


   Bases: :py:obj:`Exception`

   An exception wrapper than can be sent across threads.

   This exception captures the stack trace of the thread that raised it to improve error reporting.

   :param traceback_exception: Traceback of the orignal exception, can be obtained with :py:meth:`traceback.TracebackException.from_exception`.
   :type traceback_exception: traceback.TracebackException

   .. py:method:: __str__()

      Return str(self).



.. py:data:: __version__
   :value: '1.0.1'

   UNDR's version, conforms to Semantic Versioning 2.0.0.

.. py:function:: configuration_from_path(path: Union[str, os.PathLike]) -> Configuration

   Reads the configuration (TOML) with the given path.

   :param path: Configuration file path.
   :type path: typing.Union[str, os.PathLike]

   :raises RuntimeError: if two datasets have the same name in the configuration.

   :returns: the parsed TOML configuration.
   :rtype: Configuration


.. py:function:: default_datasets() -> list[str]

   Generates a list of the default datasets' names.

   This function calls :py:func:`name_to_url` and has the same caveats regarding caching.

   :returns: The names of the default datasets.
   :rtype: list[str]


.. py:function:: install(name: str, url: Optional[str] = None, timeout: float = constants.DEFAULT_TIMEOUT, mode: Union[str, undr.install_mode.Mode] = install_mode.Mode.LOCAL, directory: Union[str, pathlib.Path] = 'datasets', show_display: bool = True, workers: int = multiprocessing.cpu_count() * 2, force: bool = False, log_directory: Optional[pathlib.Path] = None)

   Downloads (and optionally decompresses) a dataset.

   See :py:class:`undr.install_mode.Mode` for details on the different installation strategies.

   :param name: Name of the dataset to install. Unless url is provided, it must be one of the keys returned by :py:func:`name_to_url`.
   :type name: str
   :param url: URL of the dataset. Defaults to None.
   :type url: typing.Optional[str], optional
   :param timeout: Request timeout in seconds. Defaults to :py:attr:`undr.constants.DEFAULT_TIMEOUT`.
   :type timeout: float, optional
   :param mode: Installation strategy. Defaults to :py:attr:`undr.install_mode.Mode.LOCAL`.
   :type mode: typing.Union[str, install_mode.Mode], optional
   :param directory: Path of the local directory to store datasets. Defaults to "datasets".
   :type directory: typing.Union[str, pathlib.Path], optional
   :param show_display: Whether to show a progress bar. Defaults to True.
   :type show_display: bool, optional
   :param workers: Number of parallel workers (threads). Defaults to twice :py:func:`multiprocessing.cpu_count`
   :type workers: int, optional
   :param force: Whether to re-download files even if they are already present locally. Defaults to False.
   :type force: bool, optional
   :param log_directory: Directory to store log files. Logs are not generated if this is None. Defaults to None.
   :type log_directory: typing.Optional[pathlib.Path], optional


